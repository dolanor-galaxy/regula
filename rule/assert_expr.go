package rule

import (
	"testing"
)

// exprAssertEquals defines a special operator that can only be used
// with Go's tests.  As such we do not register this expression in the
// Operators map, nor support its use in rules.  It is expected that
// this expression will instead be registered from within a test. The
// constructor that should be registered in the Operator map should be
// generated by passing the current *testing.T to the
// makeAssertEqualsConstructor function.
type exprAssertEquals struct {
	operator
	t *testing.T
}

// MakeAssertEqualsConstructor returns a new constructor function for the assertEquals expression.  It wraps a given *testing.T so that when it is evaluated it can control the test output.
func MakeAssertEqualsConstructor(t *testing.T) func() *exprAssertEquals {
	return func() *exprAssertEquals {
		return &exprAssertEquals{
			t: t,
			operator: operator{
				contract: Contract{
					OpCode:     "assertEquals",
					ReturnType: BOOLEAN,
					Terms: []Term{
						{
							Type:        ANY,
							Cardinality: MANY,
							Min:         2,
						},
					},
				},
			},
		}
	}
}

func (n *exprAssertEquals) Eval(params Params) (*Value, error) {
	opA := n.operands[0]
	vA, err := opA.Eval(params)
	if err != nil {
		return nil, err
	}

	for i := 1; i < len(n.operands); i++ {
		vB, err := n.operands[i].Eval(params)
		if err != nil {
			return nil, err
		}

		if !vA.Equal(vB) {
			n.t.Errorf("%s\n\tAssertion error: %s != %s", n.t.Name(), vA.Data, vB.Data)
			n.t.Fail()
			return BoolValue(false), nil
		}
	}

	return BoolValue(true), nil
}
